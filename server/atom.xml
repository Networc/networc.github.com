<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>Andrew C. Reed</title>
 <link href="http://andrewcreed.com/atom.xml" rel="self"/>
 <link href="http://andrewcreed.com/"/>
 <updated>2012-04-06T15:53:59-07:00</updated>
 <id>http://andrewcreed.com/</id>
 <author>
   <name>Andrew C. Reed</name>
   <email>andrew.reed@west-point.org</email>
 </author>

 
 <entry>
   <title>Keyshanc Code Walkthrough</title>
   <link href="andrewcreed.com/2012/04/06/keyshanc-code-walkthrough.html"/>
   <updated>2012-04-06T00:00:00-07:00</updated>
   <id>http://andrewcreed.com/2012/04/06/keyshanc-code-walkthrough</id>
   <content type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/Networc/keyshanc&quot;&gt;Keyshanc Source Code&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;Input Parameters&lt;/h3&gt;

&lt;p&gt;The two input parameters to the Keyshanc function are:
* An array of 95 characters (which does not need to be initialized)
* A string which serves as a &quot;password&quot;&lt;/p&gt;

&lt;h3&gt;Step 1: SHA512 &amp;amp; SHA256 Hash&lt;/h3&gt;

&lt;p&gt;The first step of the algorithm is to compute both the SHA512 and the SHA256 hash of the password.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;std::string i = SHA512(password);
std::string j = SHA256(password);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Step 2: Initialize/Reset the Array&lt;/h3&gt;

&lt;p&gt;The array of ASCII characters must be reset in order to ensure that the same substitution cipher is always produced for a given password. This step also serves to initialize the values of the array if the calling program has not already done so.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for (int x=0; x &amp;lt; 95 ; ++x)
{
    keys[x] = char(x+32);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The end result of this FOR loop is that keys[] now contains the ASCII characters 'Space' through '~', in order.&lt;/p&gt;

&lt;h3&gt;Step 3: Declare Variables&lt;/h3&gt;

&lt;p&gt;The following variables are declared:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int shuffleCode[95];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;shuffleCode[95] is an array that will eventually contain &quot;swap positions&quot;. In the final step of the Keyshanc function, the keys[] array is shuffled according to the &quot;swap positions&quot; in shuffleCode[].&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;std::string hexString = &quot;&quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;hexString is a string that temporarily holds pairs of hexadecimal characters just prior to their conversion to binary.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;std::bitset&amp;lt;8&amp;gt; aByte;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;aByte is the binary representation of hexString.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;unsigned long numByte;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;numByte is aByte after it has been converted to an integer.&lt;/p&gt;

&lt;h3&gt;Step 4: Compute Swap Positions&lt;/h3&gt;

&lt;p&gt;This step is the heart of the Keyshanc algorithm. Each of the 64 bytes of the SHA512 hash and the first 31 bytes of the SHA256 are converted to an integer within the range of 0-94.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//this FOR loop traverses the SHA512 hash string
for (int x=0; x &amp;lt; 64; ++x)
//this FOR loop traverses the SHA256 hash string
for (int x=0; x &amp;lt; 31; ++x)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Again, Keyshanc uses all 64 bytes from the SHA512 hash but only 31 bytes from the SHA256 hash.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//these two SWITCH statements process the SHA512 hexadecimal pairs
switch (i[x*2])
switch (i[(x*2)+1])
//these two SWITCH statements process the SHA256 hexadecimal pairs
switch (j[x*2])
switch (j[(x*2)+1])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since the hash strings i and j are in hexadecimal, the Keyshanc algorithm must process a pair of characters in each iteration of the FOR loops in order to capture an entire byte. The SWITCH statement indexed by [x&lt;em&gt;2] processes the first half of the byte (most significant bits), while the SWITCH statement indexed by [(x&lt;/em&gt;2)+1] processes the second half of the byte (least significant bits).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;case '0': hexString.append (&quot;0000&quot;); break;
case '1': hexString.append (&quot;0001&quot;); break;
case '2': hexString.append (&quot;0010&quot;); break;
case '3': hexString.append (&quot;0011&quot;); break;
case '4': hexString.append (&quot;0100&quot;); break;
case '5': hexString.append (&quot;0101&quot;); break;
case '6': hexString.append (&quot;0110&quot;); break;
case '7': hexString.append (&quot;0111&quot;); break;
case '8': hexString.append (&quot;1000&quot;); break;
case '9': hexString.append (&quot;1001&quot;); break;
case 'A': hexString.append (&quot;1010&quot;); break;
case 'B': hexString.append (&quot;1011&quot;); break;
case 'C': hexString.append (&quot;1100&quot;); break;
case 'D': hexString.append (&quot;1101&quot;); break;
case 'E': hexString.append (&quot;1110&quot;); break;
case 'F': hexString.append (&quot;1111&quot;); break;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These case statements convert the hexadecimal characters of the two hash strings into their binary equivalents. These binary patterns are then appended to hexString. Once both SWITCH statements have completed, hexString will contain the binary equivalent of the current hexadecimal pair.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;aByte = std::bitset&amp;lt;8&amp;gt;(hexString);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This line converts hexString into a byte.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;numByte = aByte.to_ulong();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This line converts aByte into an integer.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;shuffleCode[x] = numByte%95;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This line reduces numByte so that it is in the range of 0-94 and stores it in shuffleCode[]. This is necessary because we will use this number as a &quot;swap position&quot; in the final step of the algorithm.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hexString = &quot;&quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This final line of code resets hexString for the next iteration of the FOR loop.&lt;/p&gt;

&lt;h3&gt;Step 5: Shuffle the Array&lt;/h3&gt;

&lt;p&gt;The final step is to shuffle the array of ASCII characters.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for (int x=0; x &amp;lt; 95; ++x)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The FOR loop traverses the entire array of ASCII characters.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;char temp = keys[x];
keys[x] = keys[shuffleCode[x]];
keys[shuffleCode[x]] = temp;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This block of code swaps the current ASCII character with the ASCII character located at the position referenced by shuffleCode.&lt;/p&gt;

&lt;p&gt;For instance, assume that shuffleCode[0] is 1 and shuffleCode[1] is 2. On the first iteration of the FOR loop keys[0], which is 'Space', will be swapped with keys[1], which is '!'. On the second iteration of the FOR loop keys[1], which is now 'Space', will be swapped with keys[2], which is '&quot;'. So, after the first two iterations of the FOR loop, keys[0] is '!', keys[1] is '&quot;', and keys [2] is 'Space'.&lt;/p&gt;

&lt;p&gt;Once the shuffling is complete, keys[] represents a substitution cipher that is used by the calling program to encrypt and decrypt keystrokes. For example, if the user presses the 'Space' key, then the ASCII character located at keys[0] is transmitted. Likewise, if the user types '~', then keys[94] is transmitted. The receiving application performs a reverse lookup to determine the plaintext character.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Keyshanc Overview</title>
   <link href="andrewcreed.com/2012/04/04/keyshanc-overview.html"/>
   <updated>2012-04-04T00:00:00-07:00</updated>
   <id>http://andrewcreed.com/2012/04/04/keyshanc-overview</id>
   <content type="html">&lt;h2&gt;Background&lt;/h2&gt;

&lt;p&gt;Over the last year and a half, I have had the opportunity to work on the implementation of a medium-scale virtual desktop infrastructure (VDI) (approx. 2300 total seats). One of the benefits of a VDI is the ability to seamlessly provide the same desktop to a user whether they are working locally or remotely (e.g. telework). This allows the user to access their data and applications from home while the virtual desktop remains on the company's LAN; however, allowing a user to connect to a virtual desktop from their personal computer poses some security concerns. Chief among these risks are keyloggers since the user's primary interaction with their virtual desktop is via mouse and keyboard input.&lt;/p&gt;

&lt;p&gt;The security concern above was my initial inspiration for Keyshanc. I have since thought of other scenarios that might benefit from Keyshanc (discussed later).&lt;/p&gt;

&lt;p&gt;Note: While the military can use the &lt;a href=&quot;http://www.spi.dod.mil/lipose.htm&quot;&gt;Lightweight Portable Security (LPS)&lt;/a&gt; bootable CD to provide users with a secure workstation, many businesses may not have the funding or the ability to produce such a CD.&lt;/p&gt;

&lt;h2&gt;Goals&lt;/h2&gt;

&lt;p&gt;I set out to devise a solution that would:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;i&gt;Reasonably&lt;/i&gt; render keyloggers ineffective at recording keystrokes (i.e. the effort to decode the keystrokes would &lt;i&gt;not&lt;/i&gt; be insignificant)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Function on any workstation without the need to install any new software on the workstation itself&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;Assumptions&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Since the workstation is unaware that the user is employing Keyshanc, ASCII characters other than 'Space' through '~' (codes 32-126) cannot be altered.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Since no method is in place to ensure timing between the keyboard and destination application, a stream-based cipher cannot be used.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;i&gt;more to follow&lt;/i&gt;&lt;/p&gt;
</content>
 </entry>
 
 
</feed>
